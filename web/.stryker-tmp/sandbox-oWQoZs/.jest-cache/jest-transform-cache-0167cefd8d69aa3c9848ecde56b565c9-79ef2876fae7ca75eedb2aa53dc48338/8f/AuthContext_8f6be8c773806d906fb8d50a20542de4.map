{"version":3,"sources":["/home/jack/Documents/aclue-preprod/web/src/context/AuthContext.tsx"],"sourcesContent":["/**\n * aclue Authentication Context\n * \n * Centralised authentication state management for the entire application.\n * Provides secure user session handling, JWT token management, and\n * authentication flows for login, registration, and logout.\n * \n * Key Features:\n *   - Automatic token refresh and session persistence\n *   - Protected route authentication guards\n *   - Real-time user state synchronisation\n *   - PostHog analytics integration for user events\n *   - Comprehensive error handling and user feedback\n * \n * State Management:\n *   - Uses useReducer for predictable state updates\n *   - Persists user data to localStorage for session continuity\n *   - Handles loading states during authentication operations\n * \n * Usage:\n *   // In _app.tsx\n *   <AuthProvider>\n *     <Component {...pageProps} />\n *   </AuthProvider>\n * \n *   // In components\n *   const { user, login, logout, isAuthenticated } = useAuth();\n */\n\nimport React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { useRouter } from 'next/router';\nimport { api, tokenManager } from '@/lib/api';\nimport { appConfig } from '@/config';\nimport { User, LoginRequest, RegisterRequest } from '@/types';\nimport toast from 'react-hot-toast';\n\n// ==============================================================================\n// TYPE DEFINITIONS\n// ==============================================================================\n\n/**\n * Authentication state interface defining the current auth status.\n * \n * Tracks user session, loading states, and error conditions to\n * provide comprehensive authentication state to the application.\n */\ninterface AuthState {\n  user: User | null;        // Current authenticated user (null if not logged in)\n  isAuthenticated: boolean; // Authentication status (true if user logged in)\n  isLoading: boolean;       // Loading state during auth operations\n  isInitialized: boolean;   // Whether auth state has been initialized from storage\n  isLoggingOut: boolean;    // Logout in progress flag\n  error: string | null;     // Current error message (null if no error)\n}\n\n/**\n * Authentication context interface providing auth methods and state.\n * \n * Extends AuthState with methods for authentication operations.\n * All methods are async and handle loading states automatically.\n */\ninterface AuthContextType extends AuthState {\n  login: (credentials: LoginRequest) => Promise<void>;      // Authenticate user with email/password\n  register: (userData: RegisterRequest) => Promise<void>;   // Create new user account\n  logout: () => Promise<void>;                              // End user session and clear tokens\n  refreshToken: () => Promise<void>;                        // Refresh expired access token\n  clearError: () => void;                                   // Clear current error state\n  updateUser: (userData: Partial<User>) => void;            // Update user profile data\n}\n\n/**\n * Authentication action types for state management.\n * \n * Defines all possible state changes that can occur during\n * authentication flows. Used with useReducer for predictable\n * state updates.\n */\ntype AuthAction =\n  | { type: 'SET_LOADING'; payload: boolean }           // Update loading state\n  | { type: 'SET_USER'; payload: User | null }          // Set authenticated user\n  | { type: 'SET_ERROR'; payload: string | null }       // Set error message\n  | { type: 'SET_INITIALIZED'; payload: boolean }       // Mark auth as initialized\n  | { type: 'SET_LOGGING_OUT'; payload: boolean }       // Set logout in progress\n  | { type: 'LOGOUT' }                                  // Clear user and reset state\n  | { type: 'UPDATE_USER'; payload: Partial<User> };    // Update user profile data\n\n/**\n * Initial authentication state on application load.\n * \n * Sets default values for all auth state properties.\n * isLoading starts as true to prevent flash of unauthenticated content.\n */\nconst initialState: AuthState = {\n  user: null,             // No user authenticated initially\n  isAuthenticated: false, // Not authenticated until proven otherwise\n  isLoading: true,        // Loading while checking stored tokens\n  isInitialized: false,   // Not initialized until storage check complete\n  isLoggingOut: false,    // No logout in progress\n  error: null,            // No error initially\n};\n\n// ==============================================================================\n// STATE REDUCER\n// ==============================================================================\n\n/**\n * Authentication state reducer for predictable state management.\n * \n * Handles all authentication state changes through well-defined actions.\n * Ensures immutable state updates and consistent state transitions.\n * \n * Parameters:\n *   state: Current authentication state\n *   action: Action to perform with optional payload\n * \n * Returns:\n *   AuthState: New state after applying action\n */\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, isLoading: action.payload };\n    \n    case 'SET_USER':\n      return {\n        ...state,\n        user: action.payload,                    // Set user data\n        isAuthenticated: !!action.payload,       // Authenticated if user exists\n        isLoading: false,                        // No longer loading\n        error: null,                             // Clear any errors\n      };\n    \n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,                   // Set error message\n        isLoading: false,                        // Stop loading on error\n      };\n    \n    case 'SET_INITIALIZED':\n      return {\n        ...state,\n        isInitialized: action.payload,           // Mark as initialized\n        isLoading: !action.payload,              // Stop loading when initialized\n      };\n    \n    case 'SET_LOGGING_OUT':\n      return {\n        ...state,\n        isLoggingOut: action.payload,            // Set logout in progress flag\n      };\n    \n    case 'LOGOUT':\n      return {\n        ...initialState,                         // Reset to initial state\n        isInitialized: true,                     // Keep initialized flag\n        isLoading: false,                        // Not loading after logout\n        isLoggingOut: false,                     // Logout complete\n      };\n    \n    case 'UPDATE_USER':\n      return {\n        ...state,\n        user: state.user ? { ...state.user, ...action.payload } : null, // Merge user updates\n      };\n    \n    default:\n      return state;                              // No change for unknown actions\n  }\n};\n\n// ==============================================================================\n// CONTEXT CREATION\n// ==============================================================================\n\n/**\n * Authentication context for sharing auth state across the application.\n * \n * Created with undefined default to force proper provider usage.\n * Components must be wrapped in AuthProvider to access context.\n */\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// ==============================================================================\n// PROVIDER COMPONENT\n// ==============================================================================\n\n/**\n * Props for AuthProvider component.\n */\ninterface AuthProviderProps {\n  children: ReactNode; // Child components that need access to auth context\n}\n\n/**\n * Authentication Provider component.\n * \n * Provides authentication state and methods to all child components.\n * Handles session initialization, token refresh, and user state persistence.\n * \n * Initialization Flow:\n *   1. Check for stored tokens in localStorage\n *   2. Validate tokens with backend\n *   3. Restore user session or clear invalid tokens\n *   4. Mark authentication as initialized\n * \n * Props:\n *   children: React components that need auth context\n */\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n  const router = useRouter();\n\n  // ===========================================================================\n  // AUTHENTICATION INITIALIZATION\n  // ===========================================================================\n  \n  /**\n   * Initialize authentication state on component mount.\n   * \n   * Runs once when the app loads to:\n   *   - Check for stored authentication tokens\n   *   - Restore user session from localStorage\n   *   - Verify tokens with backend\n   *   - Handle token refresh if needed\n   *   - Clear invalid sessions\n   */\n  useEffect(() => {\n    const initializeAuth = async () => {\n      try {\n        dispatch({ type: 'SET_LOADING', payload: true });\n\n        // Check for stored access token\n        const token = tokenManager.getAccessToken();\n        \n        if (!token) {\n          // No token found - user not logged in\n          dispatch({ type: 'SET_INITIALIZED', payload: true });\n          return;\n        }\n\n        // Restore user data from localStorage for immediate UI update\n        const storedUser = localStorage.getItem(appConfig.storage.user);\n        \n        if (storedUser) {\n          try {\n            const user = JSON.parse(storedUser) as User;\n            dispatch({ type: 'SET_USER', payload: user });\n          } catch (parseError) {\n            console.warn('Invalid stored user data, clearing localStorage:', parseError);\n            // Clear corrupted data\n            localStorage.removeItem(appConfig.storage.user);\n          }\n        }\n\n        // Verify token with backend and get fresh user data\n        try {\n          const response = await api.getCurrentUser();\n          // Handle different response formats - sometimes data is wrapped, sometimes direct\n          const userData = response.data || response;\n          dispatch({ type: 'SET_USER', payload: userData });\n          \n          // Update stored user data with fresh backend data\n          localStorage.setItem(appConfig.storage.user, JSON.stringify(userData));\n        } catch (error: any) {\n          console.error('Token verification failed:', error);\n          \n          // Only try to refresh if we have a refresh token\n          const refreshToken = tokenManager.getRefreshToken();\n          if (refreshToken) {\n            try {\n              await refreshTokenInternal();\n            } catch (refreshError) {\n              console.error('Token refresh failed:', refreshError);\n              await logoutInternal();\n            }\n          } else {\n            console.warn('No refresh token available, clearing session');\n            await logoutInternal();\n          }\n        }\n      } catch (error) {\n        console.error('Auth initialization failed:', error);\n        await logoutInternal();\n      } finally {\n        dispatch({ type: 'SET_INITIALIZED', payload: true });\n      }\n    };\n\n    initializeAuth();\n  }, []);\n\n  // ===========================================================================\n  // INTERNAL HELPER FUNCTIONS\n  // ===========================================================================\n  \n  /**\n   * Internal logout function for cleanup without API calls.\n   * \n   * Used during error recovery and session cleanup.\n   * Clears all stored data and resets auth state.\n   */\n  const logoutInternal = async () => {\n    try {\n      // Clear tokens from memory and localStorage\n      tokenManager.clearTokens();\n      \n      // Clear all stored authentication data\n      Object.values(appConfig.storage).forEach(key => {\n        localStorage.removeItem(key);\n      });\n      \n      // Reset auth state\n      dispatch({ type: 'LOGOUT' });\n    } catch (error) {\n      console.error('Logout error:', error);\n    }\n  };\n\n  /**\n   * Internal token refresh function for session renewal.\n   * \n   * Uses stored refresh token to obtain new access token.\n   * Updates stored tokens with new values.\n   */\n  const refreshTokenInternal = async () => {\n    const refreshToken = tokenManager.getRefreshToken();\n    if (!refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    // Call refresh endpoint\n    const response = await api.refreshAccessToken({ refresh_token: refreshToken });\n    const { access_token, refresh_token: newRefreshToken } = response.data;\n    \n    // Store new tokens\n    tokenManager.setTokens(access_token, newRefreshToken);\n  };\n\n  // Login function\n  const login = async (credentials: LoginRequest) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'SET_ERROR', payload: null });\n\n      const response = await api.login(credentials);\n      const { access_token, refresh_token, user } = response.data;\n\n      // Store tokens\n      tokenManager.setTokens(access_token, refresh_token);\n\n      // Store user data\n      localStorage.setItem(appConfig.storage.user, JSON.stringify(user));\n\n      // Update state\n      dispatch({ type: 'SET_USER', payload: user });\n\n      // Track login event with PostHog\n      try {\n        const { trackEvent, identifyUser } = await import('@/lib/analytics');\n        \n        // Identify the user\n        identifyUser(user.id, {\n          email: user.email,\n          first_name: user.first_name,\n          last_name: user.last_name,\n          subscription_tier: user.subscription_tier,\n        });\n\n        // Track login event\n        trackEvent('user_login', {\n          method: 'email',\n          user_id: user.id,\n          timestamp: new Date().toISOString(),\n        });\n      } catch (trackingError) {\n        console.warn('Failed to track login event:', trackingError);\n      }\n\n      toast.success(appConfig.success.login);\n    } catch (error: any) {\n      console.error('Login error:', error);\n      const errorMessage = error.message || appConfig.errors.unknown;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(errorMessage);\n      throw error;\n    }\n  };\n\n  // Register function\n  const register = async (userData: RegisterRequest) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'SET_ERROR', payload: null });\n\n      const response = await api.register(userData);\n      const { access_token, refresh_token, user } = response.data;\n\n      // Store tokens\n      tokenManager.setTokens(access_token, refresh_token);\n\n      // Store user data\n      localStorage.setItem(appConfig.storage.user, JSON.stringify(user));\n\n      // Update state\n      dispatch({ type: 'SET_USER', payload: user });\n\n      // Track registration event with PostHog\n      try {\n        const { trackEvent, identifyUser } = await import('@/lib/analytics');\n        \n        // Identify the user\n        identifyUser(user.id, {\n          email: user.email,\n          first_name: user.first_name,\n          last_name: user.last_name,\n          created_at: user.created_at,\n          subscription_tier: user.subscription_tier,\n        });\n\n        // Track registration event\n        trackEvent('user_register', {\n          method: 'email',\n          marketing_consent: userData.marketing_consent,\n          user_id: user.id,\n          source: 'web',\n          timestamp: new Date().toISOString(),\n        });\n      } catch (trackingError) {\n        console.warn('Failed to track registration event:', trackingError);\n      }\n\n      toast.success(appConfig.success.register);\n    } catch (error: any) {\n      console.error('Registration error:', error);\n      const errorMessage = error.message || appConfig.errors.unknown;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(errorMessage);\n      throw error;\n    }\n  };\n\n  // Logout function\n  const logout = async () => {\n    try {\n      dispatch({ type: 'SET_LOGGING_OUT', payload: true });\n      dispatch({ type: 'SET_LOADING', payload: true });\n\n      // Call logout API\n      try {\n        await api.logout();\n      } catch (error) {\n        console.warn('Logout API call failed:', error);\n      }\n\n      // Track logout event with PostHog\n      if (state.user) {\n        try {\n          const { trackEvent, analytics } = await import('@/lib/analytics');\n          \n          trackEvent('user_logout', {\n            user_id: state.user.id,\n            timestamp: new Date().toISOString(),\n          });\n\n          // Reset PostHog user session\n          analytics.reset();\n        } catch (trackingError) {\n          console.warn('Failed to track logout event:', trackingError);\n        }\n      }\n\n      await logoutInternal();\n      \n      console.log('🚪 Logout completed, redirecting to homepage...');\n      toast.success(appConfig.success.logout);\n\n      // Small delay to ensure state update completes before redirect\n      setTimeout(() => {\n        console.log('🚪 Executing redirect to homepage');\n        router.replace('/');\n      }, 100);\n    } catch (error: any) {\n      console.error('Logout error:', error);\n      // Force logout even if API call fails\n      await logoutInternal();\n      setTimeout(() => {\n        router.replace('/');\n      }, 100);\n    }\n  };\n\n  // Refresh token function\n  const refreshToken = async () => {\n    try {\n      await refreshTokenInternal();\n    } catch (error: any) {\n      console.error('Token refresh failed:', error);\n      await logoutInternal();\n      throw error;\n    }\n  };\n\n  // Clear error function\n  const clearError = () => {\n    dispatch({ type: 'SET_ERROR', payload: null });\n  };\n\n  // Update user function\n  const updateUser = (userData: Partial<User>) => {\n    if (state.user) {\n      const updatedUser = { ...state.user, ...userData };\n      localStorage.setItem(appConfig.storage.user, JSON.stringify(updatedUser));\n      dispatch({ type: 'UPDATE_USER', payload: userData });\n    }\n  };\n\n  const value: AuthContextType = {\n    ...state,\n    login,\n    register,\n    logout,\n    refreshToken,\n    clearError,\n    updateUser,\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Hook to use auth context\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\n// Hook for protected routes\nexport const useRequireAuth = (redirectTo: string = '/auth/login') => {\n  const { isAuthenticated, isInitialized } = useAuth();\n  const router = useRouter();\n\n  useEffect(() => {\n    if (isInitialized && !isAuthenticated) {\n      const currentPath = router.asPath;\n      const redirectUrl = `${redirectTo}?redirect=${encodeURIComponent(currentPath)}`;\n      router.replace(redirectUrl);\n    }\n  }, [isAuthenticated, isInitialized, router, redirectTo]);\n\n  return { isAuthenticated, isInitialized };\n};\n\nexport default AuthContext;"],"names":["AuthProvider","useAuth","useRequireAuth","initialState","user","isAuthenticated","isLoading","isInitialized","isLoggingOut","error","authReducer","state","action","type","payload","AuthContext","createContext","undefined","children","dispatch","useReducer","router","useRouter","useEffect","initializeAuth","token","tokenManager","getAccessToken","storedUser","localStorage","getItem","appConfig","storage","JSON","parse","parseError","console","warn","removeItem","response","api","getCurrentUser","userData","data","setItem","stringify","refreshToken","getRefreshToken","refreshTokenInternal","refreshError","logoutInternal","clearTokens","Object","values","forEach","key","Error","refreshAccessToken","refresh_token","access_token","newRefreshToken","setTokens","login","credentials","trackEvent","identifyUser","id","email","first_name","last_name","subscription_tier","method","user_id","timestamp","Date","toISOString","trackingError","toast","success","errorMessage","message","errors","unknown","register","created_at","marketing_consent","source","logout","analytics","reset","log","setTimeout","replace","clearError","updateUser","updatedUser","value","Provider","context","useContext","redirectTo","currentPath","asPath","redirectUrl","encodeURIComponent"],"mappings":"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"}