3d396fa74558f6f205929d0d535f1a56
/**
 * aclue Authentication Context
 * 
 * Centralised authentication state management for the entire application.
 * Provides secure user session handling, JWT token management, and
 * authentication flows for login, registration, and logout.
 * 
 * Key Features:
 *   - Automatic token refresh and session persistence
 *   - Protected route authentication guards
 *   - Real-time user state synchronisation
 *   - PostHog analytics integration for user events
 *   - Comprehensive error handling and user feedback
 * 
 * State Management:
 *   - Uses useReducer for predictable state updates
 *   - Persists user data to localStorage for session continuity
 *   - Handles loading states during authentication operations
 * 
 * Usage:
 *   // In _app.tsx
 *   <AuthProvider>
 *     <Component {...pageProps} />
 *   </AuthProvider>
 * 
 *   // In components
 *   const { user, login, logout, isAuthenticated } = useAuth();
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AuthProvider: function() {
        return AuthProvider;
    },
    default: function() {
        return _default;
    },
    useAuth: function() {
        return useAuth;
    },
    useRequireAuth: function() {
        return useRequireAuth;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _router = require("next/router");
const _api = require("../lib/api");
const _config = require("../config");
const _reacthottoast = /*#__PURE__*/ _interop_require_default(require("react-hot-toast"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Initial authentication state on application load.
 * 
 * Sets default values for all auth state properties.
 * isLoading starts as true to prevent flash of unauthenticated content.
 */ const initialState = {
    user: null,
    isAuthenticated: false,
    isLoading: true,
    isInitialized: false,
    isLoggingOut: false,
    error: null
};
// ==============================================================================
// STATE REDUCER
// ==============================================================================
/**
 * Authentication state reducer for predictable state management.
 * 
 * Handles all authentication state changes through well-defined actions.
 * Ensures immutable state updates and consistent state transitions.
 * 
 * Parameters:
 *   state: Current authentication state
 *   action: Action to perform with optional payload
 * 
 * Returns:
 *   AuthState: New state after applying action
 */ const authReducer = (state, action)=>{
    switch(action.type){
        case "SET_LOADING":
            return {
                ...state,
                isLoading: action.payload
            };
        case "SET_USER":
            return {
                ...state,
                user: action.payload,
                isAuthenticated: !!action.payload,
                isLoading: false,
                error: null
            };
        case "SET_ERROR":
            return {
                ...state,
                error: action.payload,
                isLoading: false
            };
        case "SET_INITIALIZED":
            return {
                ...state,
                isInitialized: action.payload,
                isLoading: !action.payload
            };
        case "SET_LOGGING_OUT":
            return {
                ...state,
                isLoggingOut: action.payload
            };
        case "LOGOUT":
            return {
                ...initialState,
                isInitialized: true,
                isLoading: false,
                isLoggingOut: false
            };
        case "UPDATE_USER":
            return {
                ...state,
                user: state.user ? {
                    ...state.user,
                    ...action.payload
                } : null
            };
        default:
            return state; // No change for unknown actions
    }
};
// ==============================================================================
// CONTEXT CREATION
// ==============================================================================
/**
 * Authentication context for sharing auth state across the application.
 * 
 * Created with undefined default to force proper provider usage.
 * Components must be wrapped in AuthProvider to access context.
 */ const AuthContext = /*#__PURE__*/ (0, _react.createContext)(undefined);
const AuthProvider = ({ children })=>{
    const [state, dispatch] = (0, _react.useReducer)(authReducer, initialState);
    const router = (0, _router.useRouter)();
    // ===========================================================================
    // AUTHENTICATION INITIALIZATION
    // ===========================================================================
    /**
   * Initialize authentication state on component mount.
   * 
   * Runs once when the app loads to:
   *   - Check for stored authentication tokens
   *   - Restore user session from localStorage
   *   - Verify tokens with backend
   *   - Handle token refresh if needed
   *   - Clear invalid sessions
   */ (0, _react.useEffect)(()=>{
        const initializeAuth = async ()=>{
            try {
                dispatch({
                    type: "SET_LOADING",
                    payload: true
                });
                // Check for stored access token
                const token = _api.tokenManager.getAccessToken();
                if (!token) {
                    // No token found - user not logged in
                    dispatch({
                        type: "SET_INITIALIZED",
                        payload: true
                    });
                    return;
                }
                // Restore user data from localStorage for immediate UI update
                const storedUser = localStorage.getItem(_config.appConfig.storage.user);
                if (storedUser) {
                    try {
                        const user = JSON.parse(storedUser);
                        dispatch({
                            type: "SET_USER",
                            payload: user
                        });
                    } catch (parseError) {
                        console.warn("Invalid stored user data, clearing localStorage:", parseError);
                        // Clear corrupted data
                        localStorage.removeItem(_config.appConfig.storage.user);
                    }
                }
                // Verify token with backend and get fresh user data
                try {
                    const response = await _api.api.getCurrentUser();
                    // Handle different response formats - sometimes data is wrapped, sometimes direct
                    const userData = response.data || response;
                    dispatch({
                        type: "SET_USER",
                        payload: userData
                    });
                    // Update stored user data with fresh backend data
                    localStorage.setItem(_config.appConfig.storage.user, JSON.stringify(userData));
                } catch (error) {
                    console.error("Token verification failed:", error);
                    // Only try to refresh if we have a refresh token
                    const refreshToken = _api.tokenManager.getRefreshToken();
                    if (refreshToken) {
                        try {
                            await refreshTokenInternal();
                        } catch (refreshError) {
                            console.error("Token refresh failed:", refreshError);
                            await logoutInternal();
                        }
                    } else {
                        console.warn("No refresh token available, clearing session");
                        await logoutInternal();
                    }
                }
            } catch (error) {
                console.error("Auth initialization failed:", error);
                await logoutInternal();
            } finally{
                dispatch({
                    type: "SET_INITIALIZED",
                    payload: true
                });
            }
        };
        initializeAuth();
    }, []);
    // ===========================================================================
    // INTERNAL HELPER FUNCTIONS
    // ===========================================================================
    /**
   * Internal logout function for cleanup without API calls.
   * 
   * Used during error recovery and session cleanup.
   * Clears all stored data and resets auth state.
   */ const logoutInternal = async ()=>{
        try {
            // Clear tokens from memory and localStorage
            _api.tokenManager.clearTokens();
            // Clear all stored authentication data
            Object.values(_config.appConfig.storage).forEach((key)=>{
                localStorage.removeItem(key);
            });
            // Reset auth state
            dispatch({
                type: "LOGOUT"
            });
        } catch (error) {
            console.error("Logout error:", error);
        }
    };
    /**
   * Internal token refresh function for session renewal.
   * 
   * Uses stored refresh token to obtain new access token.
   * Updates stored tokens with new values.
   */ const refreshTokenInternal = async ()=>{
        const refreshToken = _api.tokenManager.getRefreshToken();
        if (!refreshToken) {
            throw new Error("No refresh token available");
        }
        // Call refresh endpoint
        const response = await _api.api.refreshAccessToken({
            refresh_token: refreshToken
        });
        const { access_token, refresh_token: newRefreshToken } = response.data;
        // Store new tokens
        _api.tokenManager.setTokens(access_token, newRefreshToken);
    };
    // Login function
    const login = async (credentials)=>{
        try {
            dispatch({
                type: "SET_LOADING",
                payload: true
            });
            dispatch({
                type: "SET_ERROR",
                payload: null
            });
            const response = await _api.api.login(credentials);
            const { access_token, refresh_token, user } = response.data;
            // Store tokens
            _api.tokenManager.setTokens(access_token, refresh_token);
            // Store user data
            localStorage.setItem(_config.appConfig.storage.user, JSON.stringify(user));
            // Update state
            dispatch({
                type: "SET_USER",
                payload: user
            });
            // Track login event with PostHog
            try {
                const { trackEvent, identifyUser } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/analytics")));
                // Identify the user
                identifyUser(user.id, {
                    email: user.email,
                    first_name: user.first_name,
                    last_name: user.last_name,
                    subscription_tier: user.subscription_tier
                });
                // Track login event
                trackEvent("user_login", {
                    method: "email",
                    user_id: user.id,
                    timestamp: new Date().toISOString()
                });
            } catch (trackingError) {
                console.warn("Failed to track login event:", trackingError);
            }
            _reacthottoast.default.success(_config.appConfig.success.login);
        } catch (error) {
            console.error("Login error:", error);
            const errorMessage = error.message || _config.appConfig.errors.unknown;
            dispatch({
                type: "SET_ERROR",
                payload: errorMessage
            });
            _reacthottoast.default.error(errorMessage);
            throw error;
        }
    };
    // Register function
    const register = async (userData)=>{
        try {
            dispatch({
                type: "SET_LOADING",
                payload: true
            });
            dispatch({
                type: "SET_ERROR",
                payload: null
            });
            const response = await _api.api.register(userData);
            const { access_token, refresh_token, user } = response.data;
            // Store tokens
            _api.tokenManager.setTokens(access_token, refresh_token);
            // Store user data
            localStorage.setItem(_config.appConfig.storage.user, JSON.stringify(user));
            // Update state
            dispatch({
                type: "SET_USER",
                payload: user
            });
            // Track registration event with PostHog
            try {
                const { trackEvent, identifyUser } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/analytics")));
                // Identify the user
                identifyUser(user.id, {
                    email: user.email,
                    first_name: user.first_name,
                    last_name: user.last_name,
                    created_at: user.created_at,
                    subscription_tier: user.subscription_tier
                });
                // Track registration event
                trackEvent("user_register", {
                    method: "email",
                    marketing_consent: userData.marketing_consent,
                    user_id: user.id,
                    source: "web",
                    timestamp: new Date().toISOString()
                });
            } catch (trackingError) {
                console.warn("Failed to track registration event:", trackingError);
            }
            _reacthottoast.default.success(_config.appConfig.success.register);
        } catch (error) {
            console.error("Registration error:", error);
            const errorMessage = error.message || _config.appConfig.errors.unknown;
            dispatch({
                type: "SET_ERROR",
                payload: errorMessage
            });
            _reacthottoast.default.error(errorMessage);
            throw error;
        }
    };
    // Logout function
    const logout = async ()=>{
        try {
            dispatch({
                type: "SET_LOGGING_OUT",
                payload: true
            });
            dispatch({
                type: "SET_LOADING",
                payload: true
            });
            // Call logout API
            try {
                await _api.api.logout();
            } catch (error) {
                console.warn("Logout API call failed:", error);
            }
            // Track logout event with PostHog
            if (state.user) {
                try {
                    const { trackEvent, analytics } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../lib/analytics")));
                    trackEvent("user_logout", {
                        user_id: state.user.id,
                        timestamp: new Date().toISOString()
                    });
                    // Reset PostHog user session
                    analytics.reset();
                } catch (trackingError) {
                    console.warn("Failed to track logout event:", trackingError);
                }
            }
            await logoutInternal();
            console.log("\uD83D\uDEAA Logout completed, redirecting to homepage...");
            _reacthottoast.default.success(_config.appConfig.success.logout);
            // Small delay to ensure state update completes before redirect
            setTimeout(()=>{
                console.log("\uD83D\uDEAA Executing redirect to homepage");
                router.replace("/");
            }, 100);
        } catch (error) {
            console.error("Logout error:", error);
            // Force logout even if API call fails
            await logoutInternal();
            setTimeout(()=>{
                router.replace("/");
            }, 100);
        }
    };
    // Refresh token function
    const refreshToken = async ()=>{
        try {
            await refreshTokenInternal();
        } catch (error) {
            console.error("Token refresh failed:", error);
            await logoutInternal();
            throw error;
        }
    };
    // Clear error function
    const clearError = ()=>{
        dispatch({
            type: "SET_ERROR",
            payload: null
        });
    };
    // Update user function
    const updateUser = (userData)=>{
        if (state.user) {
            const updatedUser = {
                ...state.user,
                ...userData
            };
            localStorage.setItem(_config.appConfig.storage.user, JSON.stringify(updatedUser));
            dispatch({
                type: "UPDATE_USER",
                payload: userData
            });
        }
    };
    const value = {
        ...state,
        login,
        register,
        logout,
        refreshToken,
        clearError,
        updateUser
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(AuthContext.Provider, {
        value: value,
        children: children
    });
};
const useAuth = ()=>{
    const context = (0, _react.useContext)(AuthContext);
    if (context === undefined) {
        throw new Error("useAuth must be used within an AuthProvider");
    }
    return context;
};
const useRequireAuth = (redirectTo = "/auth/login")=>{
    const { isAuthenticated, isInitialized } = useAuth();
    const router = (0, _router.useRouter)();
    (0, _react.useEffect)(()=>{
        if (isInitialized && !isAuthenticated) {
            const currentPath = router.asPath;
            const redirectUrl = `${redirectTo}?redirect=${encodeURIComponent(currentPath)}`;
            router.replace(redirectUrl);
        }
    }, [
        isAuthenticated,
        isInitialized,
        router,
        redirectTo
    ]);
    return {
        isAuthenticated,
        isInitialized
    };
};
const _default = AuthContext;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2phY2svRG9jdW1lbnRzL2FjbHVlLXByZXByb2Qvd2ViL3NyYy9jb250ZXh0L0F1dGhDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGFjbHVlIEF1dGhlbnRpY2F0aW9uIENvbnRleHRcbiAqIFxuICogQ2VudHJhbGlzZWQgYXV0aGVudGljYXRpb24gc3RhdGUgbWFuYWdlbWVudCBmb3IgdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAqIFByb3ZpZGVzIHNlY3VyZSB1c2VyIHNlc3Npb24gaGFuZGxpbmcsIEpXVCB0b2tlbiBtYW5hZ2VtZW50LCBhbmRcbiAqIGF1dGhlbnRpY2F0aW9uIGZsb3dzIGZvciBsb2dpbiwgcmVnaXN0cmF0aW9uLCBhbmQgbG9nb3V0LlxuICogXG4gKiBLZXkgRmVhdHVyZXM6XG4gKiAgIC0gQXV0b21hdGljIHRva2VuIHJlZnJlc2ggYW5kIHNlc3Npb24gcGVyc2lzdGVuY2VcbiAqICAgLSBQcm90ZWN0ZWQgcm91dGUgYXV0aGVudGljYXRpb24gZ3VhcmRzXG4gKiAgIC0gUmVhbC10aW1lIHVzZXIgc3RhdGUgc3luY2hyb25pc2F0aW9uXG4gKiAgIC0gUG9zdEhvZyBhbmFseXRpY3MgaW50ZWdyYXRpb24gZm9yIHVzZXIgZXZlbnRzXG4gKiAgIC0gQ29tcHJlaGVuc2l2ZSBlcnJvciBoYW5kbGluZyBhbmQgdXNlciBmZWVkYmFja1xuICogXG4gKiBTdGF0ZSBNYW5hZ2VtZW50OlxuICogICAtIFVzZXMgdXNlUmVkdWNlciBmb3IgcHJlZGljdGFibGUgc3RhdGUgdXBkYXRlc1xuICogICAtIFBlcnNpc3RzIHVzZXIgZGF0YSB0byBsb2NhbFN0b3JhZ2UgZm9yIHNlc3Npb24gY29udGludWl0eVxuICogICAtIEhhbmRsZXMgbG9hZGluZyBzdGF0ZXMgZHVyaW5nIGF1dGhlbnRpY2F0aW9uIG9wZXJhdGlvbnNcbiAqIFxuICogVXNhZ2U6XG4gKiAgIC8vIEluIF9hcHAudHN4XG4gKiAgIDxBdXRoUHJvdmlkZXI+XG4gKiAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICogICA8L0F1dGhQcm92aWRlcj5cbiAqIFxuICogICAvLyBJbiBjb21wb25lbnRzXG4gKiAgIGNvbnN0IHsgdXNlciwgbG9naW4sIGxvZ291dCwgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKCk7XG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZHVjZXIsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xuaW1wb3J0IHsgYXBpLCB0b2tlbk1hbmFnZXIgfSBmcm9tICdAL2xpYi9hcGknO1xuaW1wb3J0IHsgYXBwQ29uZmlnIH0gZnJvbSAnQC9jb25maWcnO1xuaW1wb3J0IHsgVXNlciwgTG9naW5SZXF1ZXN0LCBSZWdpc3RlclJlcXVlc3QgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRZUEUgREVGSU5JVElPTlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEF1dGhlbnRpY2F0aW9uIHN0YXRlIGludGVyZmFjZSBkZWZpbmluZyB0aGUgY3VycmVudCBhdXRoIHN0YXR1cy5cbiAqIFxuICogVHJhY2tzIHVzZXIgc2Vzc2lvbiwgbG9hZGluZyBzdGF0ZXMsIGFuZCBlcnJvciBjb25kaXRpb25zIHRvXG4gKiBwcm92aWRlIGNvbXByZWhlbnNpdmUgYXV0aGVudGljYXRpb24gc3RhdGUgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICovXG5pbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgdXNlcjogVXNlciB8IG51bGw7ICAgICAgICAvLyBDdXJyZW50IGF1dGhlbnRpY2F0ZWQgdXNlciAobnVsbCBpZiBub3QgbG9nZ2VkIGluKVxuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47IC8vIEF1dGhlbnRpY2F0aW9uIHN0YXR1cyAodHJ1ZSBpZiB1c2VyIGxvZ2dlZCBpbilcbiAgaXNMb2FkaW5nOiBib29sZWFuOyAgICAgICAvLyBMb2FkaW5nIHN0YXRlIGR1cmluZyBhdXRoIG9wZXJhdGlvbnNcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhbjsgICAvLyBXaGV0aGVyIGF1dGggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgZnJvbSBzdG9yYWdlXG4gIGlzTG9nZ2luZ091dDogYm9vbGVhbjsgICAgLy8gTG9nb3V0IGluIHByb2dyZXNzIGZsYWdcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7ICAgICAvLyBDdXJyZW50IGVycm9yIG1lc3NhZ2UgKG51bGwgaWYgbm8gZXJyb3IpXG59XG5cbi8qKlxuICogQXV0aGVudGljYXRpb24gY29udGV4dCBpbnRlcmZhY2UgcHJvdmlkaW5nIGF1dGggbWV0aG9kcyBhbmQgc3RhdGUuXG4gKiBcbiAqIEV4dGVuZHMgQXV0aFN0YXRlIHdpdGggbWV0aG9kcyBmb3IgYXV0aGVudGljYXRpb24gb3BlcmF0aW9ucy5cbiAqIEFsbCBtZXRob2RzIGFyZSBhc3luYyBhbmQgaGFuZGxlIGxvYWRpbmcgc3RhdGVzIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUgZXh0ZW5kcyBBdXRoU3RhdGUge1xuICBsb2dpbjogKGNyZWRlbnRpYWxzOiBMb2dpblJlcXVlc3QpID0+IFByb21pc2U8dm9pZD47ICAgICAgLy8gQXV0aGVudGljYXRlIHVzZXIgd2l0aCBlbWFpbC9wYXNzd29yZFxuICByZWdpc3RlcjogKHVzZXJEYXRhOiBSZWdpc3RlclJlcXVlc3QpID0+IFByb21pc2U8dm9pZD47ICAgLy8gQ3JlYXRlIG5ldyB1c2VyIGFjY291bnRcbiAgbG9nb3V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCB1c2VyIHNlc3Npb24gYW5kIGNsZWFyIHRva2Vuc1xuICByZWZyZXNoVG9rZW46ICgpID0+IFByb21pc2U8dm9pZD47ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmcmVzaCBleHBpcmVkIGFjY2VzcyB0b2tlblxuICBjbGVhckVycm9yOiAoKSA9PiB2b2lkOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgY3VycmVudCBlcnJvciBzdGF0ZVxuICB1cGRhdGVVc2VyOiAodXNlckRhdGE6IFBhcnRpYWw8VXNlcj4pID0+IHZvaWQ7ICAgICAgICAgICAgLy8gVXBkYXRlIHVzZXIgcHJvZmlsZSBkYXRhXG59XG5cbi8qKlxuICogQXV0aGVudGljYXRpb24gYWN0aW9uIHR5cGVzIGZvciBzdGF0ZSBtYW5hZ2VtZW50LlxuICogXG4gKiBEZWZpbmVzIGFsbCBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2VzIHRoYXQgY2FuIG9jY3VyIGR1cmluZ1xuICogYXV0aGVudGljYXRpb24gZmxvd3MuIFVzZWQgd2l0aCB1c2VSZWR1Y2VyIGZvciBwcmVkaWN0YWJsZVxuICogc3RhdGUgdXBkYXRlcy5cbiAqL1xudHlwZSBBdXRoQWN0aW9uID1cbiAgfCB7IHR5cGU6ICdTRVRfTE9BRElORyc7IHBheWxvYWQ6IGJvb2xlYW4gfSAgICAgICAgICAgLy8gVXBkYXRlIGxvYWRpbmcgc3RhdGVcbiAgfCB7IHR5cGU6ICdTRVRfVVNFUic7IHBheWxvYWQ6IFVzZXIgfCBudWxsIH0gICAgICAgICAgLy8gU2V0IGF1dGhlbnRpY2F0ZWQgdXNlclxuICB8IHsgdHlwZTogJ1NFVF9FUlJPUic7IHBheWxvYWQ6IHN0cmluZyB8IG51bGwgfSAgICAgICAvLyBTZXQgZXJyb3IgbWVzc2FnZVxuICB8IHsgdHlwZTogJ1NFVF9JTklUSUFMSVpFRCc7IHBheWxvYWQ6IGJvb2xlYW4gfSAgICAgICAvLyBNYXJrIGF1dGggYXMgaW5pdGlhbGl6ZWRcbiAgfCB7IHR5cGU6ICdTRVRfTE9HR0lOR19PVVQnOyBwYXlsb2FkOiBib29sZWFuIH0gICAgICAgLy8gU2V0IGxvZ291dCBpbiBwcm9ncmVzc1xuICB8IHsgdHlwZTogJ0xPR09VVCcgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB1c2VyIGFuZCByZXNldCBzdGF0ZVxuICB8IHsgdHlwZTogJ1VQREFURV9VU0VSJzsgcGF5bG9hZDogUGFydGlhbDxVc2VyPiB9OyAgICAvLyBVcGRhdGUgdXNlciBwcm9maWxlIGRhdGFcblxuLyoqXG4gKiBJbml0aWFsIGF1dGhlbnRpY2F0aW9uIHN0YXRlIG9uIGFwcGxpY2F0aW9uIGxvYWQuXG4gKiBcbiAqIFNldHMgZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBhdXRoIHN0YXRlIHByb3BlcnRpZXMuXG4gKiBpc0xvYWRpbmcgc3RhcnRzIGFzIHRydWUgdG8gcHJldmVudCBmbGFzaCBvZiB1bmF1dGhlbnRpY2F0ZWQgY29udGVudC5cbiAqL1xuY29uc3QgaW5pdGlhbFN0YXRlOiBBdXRoU3RhdGUgPSB7XG4gIHVzZXI6IG51bGwsICAgICAgICAgICAgIC8vIE5vIHVzZXIgYXV0aGVudGljYXRlZCBpbml0aWFsbHlcbiAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSwgLy8gTm90IGF1dGhlbnRpY2F0ZWQgdW50aWwgcHJvdmVuIG90aGVyd2lzZVxuICBpc0xvYWRpbmc6IHRydWUsICAgICAgICAvLyBMb2FkaW5nIHdoaWxlIGNoZWNraW5nIHN0b3JlZCB0b2tlbnNcbiAgaXNJbml0aWFsaXplZDogZmFsc2UsICAgLy8gTm90IGluaXRpYWxpemVkIHVudGlsIHN0b3JhZ2UgY2hlY2sgY29tcGxldGVcbiAgaXNMb2dnaW5nT3V0OiBmYWxzZSwgICAgLy8gTm8gbG9nb3V0IGluIHByb2dyZXNzXG4gIGVycm9yOiBudWxsLCAgICAgICAgICAgIC8vIE5vIGVycm9yIGluaXRpYWxseVxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTVEFURSBSRURVQ0VSXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBzdGF0ZSByZWR1Y2VyIGZvciBwcmVkaWN0YWJsZSBzdGF0ZSBtYW5hZ2VtZW50LlxuICogXG4gKiBIYW5kbGVzIGFsbCBhdXRoZW50aWNhdGlvbiBzdGF0ZSBjaGFuZ2VzIHRocm91Z2ggd2VsbC1kZWZpbmVkIGFjdGlvbnMuXG4gKiBFbnN1cmVzIGltbXV0YWJsZSBzdGF0ZSB1cGRhdGVzIGFuZCBjb25zaXN0ZW50IHN0YXRlIHRyYW5zaXRpb25zLlxuICogXG4gKiBQYXJhbWV0ZXJzOlxuICogICBzdGF0ZTogQ3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0ZVxuICogICBhY3Rpb246IEFjdGlvbiB0byBwZXJmb3JtIHdpdGggb3B0aW9uYWwgcGF5bG9hZFxuICogXG4gKiBSZXR1cm5zOlxuICogICBBdXRoU3RhdGU6IE5ldyBzdGF0ZSBhZnRlciBhcHBseWluZyBhY3Rpb25cbiAqL1xuY29uc3QgYXV0aFJlZHVjZXIgPSAoc3RhdGU6IEF1dGhTdGF0ZSwgYWN0aW9uOiBBdXRoQWN0aW9uKTogQXV0aFN0YXRlID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1NFVF9MT0FESU5HJzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBpc0xvYWRpbmc6IGFjdGlvbi5wYXlsb2FkIH07XG4gICAgXG4gICAgY2FzZSAnU0VUX1VTRVInOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHVzZXI6IGFjdGlvbi5wYXlsb2FkLCAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHVzZXIgZGF0YVxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6ICEhYWN0aW9uLnBheWxvYWQsICAgICAgIC8vIEF1dGhlbnRpY2F0ZWQgaWYgdXNlciBleGlzdHNcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBsb25nZXIgbG9hZGluZ1xuICAgICAgICBlcnJvcjogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIGFueSBlcnJvcnNcbiAgICAgIH07XG4gICAgXG4gICAgY2FzZSAnU0VUX0VSUk9SJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBlcnJvcjogYWN0aW9uLnBheWxvYWQsICAgICAgICAgICAgICAgICAgIC8vIFNldCBlcnJvciBtZXNzYWdlXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBsb2FkaW5nIG9uIGVycm9yXG4gICAgICB9O1xuICAgIFxuICAgIGNhc2UgJ1NFVF9JTklUSUFMSVpFRCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNJbml0aWFsaXplZDogYWN0aW9uLnBheWxvYWQsICAgICAgICAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgICAgIGlzTG9hZGluZzogIWFjdGlvbi5wYXlsb2FkLCAgICAgICAgICAgICAgLy8gU3RvcCBsb2FkaW5nIHdoZW4gaW5pdGlhbGl6ZWRcbiAgICAgIH07XG4gICAgXG4gICAgY2FzZSAnU0VUX0xPR0dJTkdfT1VUJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvZ2dpbmdPdXQ6IGFjdGlvbi5wYXlsb2FkLCAgICAgICAgICAgIC8vIFNldCBsb2dvdXQgaW4gcHJvZ3Jlc3MgZmxhZ1xuICAgICAgfTtcbiAgICBcbiAgICBjYXNlICdMT0dPVVQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0byBpbml0aWFsIHN0YXRlXG4gICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRydWUsICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBpbml0aWFsaXplZCBmbGFnXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGxvYWRpbmcgYWZ0ZXIgbG9nb3V0XG4gICAgICAgIGlzTG9nZ2luZ091dDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgLy8gTG9nb3V0IGNvbXBsZXRlXG4gICAgICB9O1xuICAgIFxuICAgIGNhc2UgJ1VQREFURV9VU0VSJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB1c2VyOiBzdGF0ZS51c2VyID8geyAuLi5zdGF0ZS51c2VyLCAuLi5hY3Rpb24ucGF5bG9hZCB9IDogbnVsbCwgLy8gTWVyZ2UgdXNlciB1cGRhdGVzXG4gICAgICB9O1xuICAgIFxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlIGZvciB1bmtub3duIGFjdGlvbnNcbiAgfVxufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDT05URVhUIENSRUFUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBjb250ZXh0IGZvciBzaGFyaW5nIGF1dGggc3RhdGUgYWNyb3NzIHRoZSBhcHBsaWNhdGlvbi5cbiAqIFxuICogQ3JlYXRlZCB3aXRoIHVuZGVmaW5lZCBkZWZhdWx0IHRvIGZvcmNlIHByb3BlciBwcm92aWRlciB1c2FnZS5cbiAqIENvbXBvbmVudHMgbXVzdCBiZSB3cmFwcGVkIGluIEF1dGhQcm92aWRlciB0byBhY2Nlc3MgY29udGV4dC5cbiAqL1xuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQUk9WSURFUiBDT01QT05FTlRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFByb3BzIGZvciBBdXRoUHJvdmlkZXIgY29tcG9uZW50LlxuICovXG5pbnRlcmZhY2UgQXV0aFByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlOyAvLyBDaGlsZCBjb21wb25lbnRzIHRoYXQgbmVlZCBhY2Nlc3MgdG8gYXV0aCBjb250ZXh0XG59XG5cbi8qKlxuICogQXV0aGVudGljYXRpb24gUHJvdmlkZXIgY29tcG9uZW50LlxuICogXG4gKiBQcm92aWRlcyBhdXRoZW50aWNhdGlvbiBzdGF0ZSBhbmQgbWV0aG9kcyB0byBhbGwgY2hpbGQgY29tcG9uZW50cy5cbiAqIEhhbmRsZXMgc2Vzc2lvbiBpbml0aWFsaXphdGlvbiwgdG9rZW4gcmVmcmVzaCwgYW5kIHVzZXIgc3RhdGUgcGVyc2lzdGVuY2UuXG4gKiBcbiAqIEluaXRpYWxpemF0aW9uIEZsb3c6XG4gKiAgIDEuIENoZWNrIGZvciBzdG9yZWQgdG9rZW5zIGluIGxvY2FsU3RvcmFnZVxuICogICAyLiBWYWxpZGF0ZSB0b2tlbnMgd2l0aCBiYWNrZW5kXG4gKiAgIDMuIFJlc3RvcmUgdXNlciBzZXNzaW9uIG9yIGNsZWFyIGludmFsaWQgdG9rZW5zXG4gKiAgIDQuIE1hcmsgYXV0aGVudGljYXRpb24gYXMgaW5pdGlhbGl6ZWRcbiAqIFxuICogUHJvcHM6XG4gKiAgIGNoaWxkcmVuOiBSZWFjdCBjb21wb25lbnRzIHRoYXQgbmVlZCBhdXRoIGNvbnRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlcjogUmVhY3QuRkM8QXV0aFByb3ZpZGVyUHJvcHM+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHVzZVJlZHVjZXIoYXV0aFJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBVVRIRU5USUNBVElPTiBJTklUSUFMSVpBVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGF1dGhlbnRpY2F0aW9uIHN0YXRlIG9uIGNvbXBvbmVudCBtb3VudC5cbiAgICogXG4gICAqIFJ1bnMgb25jZSB3aGVuIHRoZSBhcHAgbG9hZHMgdG86XG4gICAqICAgLSBDaGVjayBmb3Igc3RvcmVkIGF1dGhlbnRpY2F0aW9uIHRva2Vuc1xuICAgKiAgIC0gUmVzdG9yZSB1c2VyIHNlc3Npb24gZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICogICAtIFZlcmlmeSB0b2tlbnMgd2l0aCBiYWNrZW5kXG4gICAqICAgLSBIYW5kbGUgdG9rZW4gcmVmcmVzaCBpZiBuZWVkZWRcbiAgICogICAtIENsZWFyIGludmFsaWQgc2Vzc2lvbnNcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZUF1dGggPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfTE9BRElORycsIHBheWxvYWQ6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0b3JlZCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbk1hbmFnZXIuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAvLyBObyB0b2tlbiBmb3VuZCAtIHVzZXIgbm90IGxvZ2dlZCBpblxuICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9JTklUSUFMSVpFRCcsIHBheWxvYWQ6IHRydWUgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdG9yZSB1c2VyIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UgZm9yIGltbWVkaWF0ZSBVSSB1cGRhdGVcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGFwcENvbmZpZy5zdG9yYWdlLnVzZXIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0b3JlZFVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IEpTT04ucGFyc2Uoc3RvcmVkVXNlcikgYXMgVXNlcjtcbiAgICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9VU0VSJywgcGF5bG9hZDogdXNlciB9KTtcbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgc3RvcmVkIHVzZXIgZGF0YSwgY2xlYXJpbmcgbG9jYWxTdG9yYWdlOicsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgY29ycnVwdGVkIGRhdGFcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGFwcENvbmZpZy5zdG9yYWdlLnVzZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0b2tlbiB3aXRoIGJhY2tlbmQgYW5kIGdldCBmcmVzaCB1c2VyIGRhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcmVzcG9uc2UgZm9ybWF0cyAtIHNvbWV0aW1lcyBkYXRhIGlzIHdyYXBwZWQsIHNvbWV0aW1lcyBkaXJlY3RcbiAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHJlc3BvbnNlLmRhdGEgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX1VTRVInLCBwYXlsb2FkOiB1c2VyRGF0YSB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3RvcmVkIHVzZXIgZGF0YSB3aXRoIGZyZXNoIGJhY2tlbmQgZGF0YVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGFwcENvbmZpZy5zdG9yYWdlLnVzZXIsIEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiB2ZXJpZmljYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBPbmx5IHRyeSB0byByZWZyZXNoIGlmIHdlIGhhdmUgYSByZWZyZXNoIHRva2VuXG4gICAgICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gdG9rZW5NYW5hZ2VyLmdldFJlZnJlc2hUb2tlbigpO1xuICAgICAgICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hUb2tlbkludGVybmFsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChyZWZyZXNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcmVmcmVzaCBmYWlsZWQ6JywgcmVmcmVzaEVycm9yKTtcbiAgICAgICAgICAgICAgYXdhaXQgbG9nb3V0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyByZWZyZXNoIHRva2VuIGF2YWlsYWJsZSwgY2xlYXJpbmcgc2Vzc2lvbicpO1xuICAgICAgICAgICAgYXdhaXQgbG9nb3V0SW50ZXJuYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGggaW5pdGlhbGl6YXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgYXdhaXQgbG9nb3V0SW50ZXJuYWwoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9JTklUSUFMSVpFRCcsIHBheWxvYWQ6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRpYWxpemVBdXRoKCk7XG4gIH0sIFtdKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSU5URVJOQUwgSEVMUEVSIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBsb2dvdXQgZnVuY3Rpb24gZm9yIGNsZWFudXAgd2l0aG91dCBBUEkgY2FsbHMuXG4gICAqIFxuICAgKiBVc2VkIGR1cmluZyBlcnJvciByZWNvdmVyeSBhbmQgc2Vzc2lvbiBjbGVhbnVwLlxuICAgKiBDbGVhcnMgYWxsIHN0b3JlZCBkYXRhIGFuZCByZXNldHMgYXV0aCBzdGF0ZS5cbiAgICovXG4gIGNvbnN0IGxvZ291dEludGVybmFsID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDbGVhciB0b2tlbnMgZnJvbSBtZW1vcnkgYW5kIGxvY2FsU3RvcmFnZVxuICAgICAgdG9rZW5NYW5hZ2VyLmNsZWFyVG9rZW5zKCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGFsbCBzdG9yZWQgYXV0aGVudGljYXRpb24gZGF0YVxuICAgICAgT2JqZWN0LnZhbHVlcyhhcHBDb25maWcuc3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0IGF1dGggc3RhdGVcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0xPR09VVCcgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ291dCBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCB0b2tlbiByZWZyZXNoIGZ1bmN0aW9uIGZvciBzZXNzaW9uIHJlbmV3YWwuXG4gICAqIFxuICAgKiBVc2VzIHN0b3JlZCByZWZyZXNoIHRva2VuIHRvIG9idGFpbiBuZXcgYWNjZXNzIHRva2VuLlxuICAgKiBVcGRhdGVzIHN0b3JlZCB0b2tlbnMgd2l0aCBuZXcgdmFsdWVzLlxuICAgKi9cbiAgY29uc3QgcmVmcmVzaFRva2VuSW50ZXJuYWwgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gdG9rZW5NYW5hZ2VyLmdldFJlZnJlc2hUb2tlbigpO1xuICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCByZWZyZXNoIGVuZHBvaW50XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucmVmcmVzaEFjY2Vzc1Rva2VuKHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0pO1xuICAgIGNvbnN0IHsgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuOiBuZXdSZWZyZXNoVG9rZW4gfSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgXG4gICAgLy8gU3RvcmUgbmV3IHRva2Vuc1xuICAgIHRva2VuTWFuYWdlci5zZXRUb2tlbnMoYWNjZXNzX3Rva2VuLCBuZXdSZWZyZXNoVG9rZW4pO1xuICB9O1xuXG4gIC8vIExvZ2luIGZ1bmN0aW9uXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGNyZWRlbnRpYWxzOiBMb2dpblJlcXVlc3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0xPQURJTkcnLCBwYXlsb2FkOiB0cnVlIH0pO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VSUk9SJywgcGF5bG9hZDogbnVsbCB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkubG9naW4oY3JlZGVudGlhbHMpO1xuICAgICAgY29uc3QgeyBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIHVzZXIgfSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgIC8vIFN0b3JlIHRva2Vuc1xuICAgICAgdG9rZW5NYW5hZ2VyLnNldFRva2VucyhhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4pO1xuXG4gICAgICAvLyBTdG9yZSB1c2VyIGRhdGFcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGFwcENvbmZpZy5zdG9yYWdlLnVzZXIsIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcblxuICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfVVNFUicsIHBheWxvYWQ6IHVzZXIgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGxvZ2luIGV2ZW50IHdpdGggUG9zdEhvZ1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0cmFja0V2ZW50LCBpZGVudGlmeVVzZXIgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvYW5hbHl0aWNzJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZGVudGlmeSB0aGUgdXNlclxuICAgICAgICBpZGVudGlmeVVzZXIodXNlci5pZCwge1xuICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgIGZpcnN0X25hbWU6IHVzZXIuZmlyc3RfbmFtZSxcbiAgICAgICAgICBsYXN0X25hbWU6IHVzZXIubGFzdF9uYW1lLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbl90aWVyOiB1c2VyLnN1YnNjcmlwdGlvbl90aWVyLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUcmFjayBsb2dpbiBldmVudFxuICAgICAgICB0cmFja0V2ZW50KCd1c2VyX2xvZ2luJywge1xuICAgICAgICAgIG1ldGhvZDogJ2VtYWlsJyxcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKHRyYWNraW5nRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdHJhY2sgbG9naW4gZXZlbnQ6JywgdHJhY2tpbmdFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHRvYXN0LnN1Y2Nlc3MoYXBwQ29uZmlnLnN1Y2Nlc3MubG9naW4pO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgYXBwQ29uZmlnLmVycm9ycy51bmtub3duO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VSUk9SJywgcGF5bG9hZDogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgdG9hc3QuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdpc3RlciBmdW5jdGlvblxuICBjb25zdCByZWdpc3RlciA9IGFzeW5jICh1c2VyRGF0YTogUmVnaXN0ZXJSZXF1ZXN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9MT0FESU5HJywgcGF5bG9hZDogdHJ1ZSB9KTtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FUlJPUicsIHBheWxvYWQ6IG51bGwgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnJlZ2lzdGVyKHVzZXJEYXRhKTtcbiAgICAgIGNvbnN0IHsgYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuLCB1c2VyIH0gPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAvLyBTdG9yZSB0b2tlbnNcbiAgICAgIHRva2VuTWFuYWdlci5zZXRUb2tlbnMoYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuKTtcblxuICAgICAgLy8gU3RvcmUgdXNlciBkYXRhXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBDb25maWcuc3RvcmFnZS51c2VyLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX1VTRVInLCBwYXlsb2FkOiB1c2VyIH0pO1xuXG4gICAgICAvLyBUcmFjayByZWdpc3RyYXRpb24gZXZlbnQgd2l0aCBQb3N0SG9nXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHRyYWNrRXZlbnQsIGlkZW50aWZ5VXNlciB9ID0gYXdhaXQgaW1wb3J0KCdAL2xpYi9hbmFseXRpY3MnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElkZW50aWZ5IHRoZSB1c2VyXG4gICAgICAgIGlkZW50aWZ5VXNlcih1c2VyLmlkLCB7XG4gICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgZmlyc3RfbmFtZTogdXNlci5maXJzdF9uYW1lLFxuICAgICAgICAgIGxhc3RfbmFtZTogdXNlci5sYXN0X25hbWUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogdXNlci5jcmVhdGVkX2F0LFxuICAgICAgICAgIHN1YnNjcmlwdGlvbl90aWVyOiB1c2VyLnN1YnNjcmlwdGlvbl90aWVyLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUcmFjayByZWdpc3RyYXRpb24gZXZlbnRcbiAgICAgICAgdHJhY2tFdmVudCgndXNlcl9yZWdpc3RlcicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdlbWFpbCcsXG4gICAgICAgICAgbWFya2V0aW5nX2NvbnNlbnQ6IHVzZXJEYXRhLm1hcmtldGluZ19jb25zZW50LFxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgc291cmNlOiAnd2ViJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoICh0cmFja2luZ0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHRyYWNrIHJlZ2lzdHJhdGlvbiBldmVudDonLCB0cmFja2luZ0Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgdG9hc3Quc3VjY2VzcyhhcHBDb25maWcuc3VjY2Vzcy5yZWdpc3Rlcik7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgYXBwQ29uZmlnLmVycm9ycy51bmtub3duO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VSUk9SJywgcGF5bG9hZDogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgdG9hc3QuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvLyBMb2dvdXQgZnVuY3Rpb25cbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfTE9HR0lOR19PVVQnLCBwYXlsb2FkOiB0cnVlIH0pO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0xPQURJTkcnLCBwYXlsb2FkOiB0cnVlIH0pO1xuXG4gICAgICAvLyBDYWxsIGxvZ291dCBBUElcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGFwaS5sb2dvdXQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTG9nb3V0IEFQSSBjYWxsIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWNrIGxvZ291dCBldmVudCB3aXRoIFBvc3RIb2dcbiAgICAgIGlmIChzdGF0ZS51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB0cmFja0V2ZW50LCBhbmFseXRpY3MgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvYW5hbHl0aWNzJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJhY2tFdmVudCgndXNlcl9sb2dvdXQnLCB7XG4gICAgICAgICAgICB1c2VyX2lkOiBzdGF0ZS51c2VyLmlkLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBSZXNldCBQb3N0SG9nIHVzZXIgc2Vzc2lvblxuICAgICAgICAgIGFuYWx5dGljcy5yZXNldCgpO1xuICAgICAgICB9IGNhdGNoICh0cmFja2luZ0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdHJhY2sgbG9nb3V0IGV2ZW50OicsIHRyYWNraW5nRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGxvZ291dEludGVybmFsKCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qqIExvZ291dCBjb21wbGV0ZWQsIHJlZGlyZWN0aW5nIHRvIGhvbWVwYWdlLi4uJyk7XG4gICAgICB0b2FzdC5zdWNjZXNzKGFwcENvbmZpZy5zdWNjZXNzLmxvZ291dCk7XG5cbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzdGF0ZSB1cGRhdGUgY29tcGxldGVzIGJlZm9yZSByZWRpcmVjdFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qqIEV4ZWN1dGluZyByZWRpcmVjdCB0byBob21lcGFnZScpO1xuICAgICAgICByb3V0ZXIucmVwbGFjZSgnLycpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dvdXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgLy8gRm9yY2UgbG9nb3V0IGV2ZW4gaWYgQVBJIGNhbGwgZmFpbHNcbiAgICAgIGF3YWl0IGxvZ291dEludGVybmFsKCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcm91dGVyLnJlcGxhY2UoJy8nKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZnJlc2ggdG9rZW4gZnVuY3Rpb25cbiAgY29uc3QgcmVmcmVzaFRva2VuID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZWZyZXNoVG9rZW5JbnRlcm5hbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIGF3YWl0IGxvZ291dEludGVybmFsKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2xlYXIgZXJyb3IgZnVuY3Rpb25cbiAgY29uc3QgY2xlYXJFcnJvciA9ICgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdTRVRfRVJST1InLCBwYXlsb2FkOiBudWxsIH0pO1xuICB9O1xuXG4gIC8vIFVwZGF0ZSB1c2VyIGZ1bmN0aW9uXG4gIGNvbnN0IHVwZGF0ZVVzZXIgPSAodXNlckRhdGE6IFBhcnRpYWw8VXNlcj4pID0+IHtcbiAgICBpZiAoc3RhdGUudXNlcikge1xuICAgICAgY29uc3QgdXBkYXRlZFVzZXIgPSB7IC4uLnN0YXRlLnVzZXIsIC4uLnVzZXJEYXRhIH07XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBDb25maWcuc3RvcmFnZS51c2VyLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkVXNlcikpO1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiAnVVBEQVRFX1VTRVInLCBwYXlsb2FkOiB1c2VyRGF0YSB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmFsdWU6IEF1dGhDb250ZXh0VHlwZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsb2dpbixcbiAgICByZWdpc3RlcixcbiAgICBsb2dvdXQsXG4gICAgcmVmcmVzaFRva2VuLFxuICAgIGNsZWFyRXJyb3IsXG4gICAgdXBkYXRlVXNlcixcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG4vLyBIb29rIHRvIHVzZSBhdXRoIGNvbnRleHRcbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCk6IEF1dGhDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLy8gSG9vayBmb3IgcHJvdGVjdGVkIHJvdXRlc1xuZXhwb3J0IGNvbnN0IHVzZVJlcXVpcmVBdXRoID0gKHJlZGlyZWN0VG86IHN0cmluZyA9ICcvYXV0aC9sb2dpbicpID0+IHtcbiAgY29uc3QgeyBpc0F1dGhlbnRpY2F0ZWQsIGlzSW5pdGlhbGl6ZWQgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNJbml0aWFsaXplZCAmJiAhaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBjb25zdCBjdXJyZW50UGF0aCA9IHJvdXRlci5hc1BhdGg7XG4gICAgICBjb25zdCByZWRpcmVjdFVybCA9IGAke3JlZGlyZWN0VG99P3JlZGlyZWN0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1cnJlbnRQYXRoKX1gO1xuICAgICAgcm91dGVyLnJlcGxhY2UocmVkaXJlY3RVcmwpO1xuICAgIH1cbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgaXNJbml0aWFsaXplZCwgcm91dGVyLCByZWRpcmVjdFRvXSk7XG5cbiAgcmV0dXJuIHsgaXNBdXRoZW50aWNhdGVkLCBpc0luaXRpYWxpemVkIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdXRoQ29udGV4dDsiXSwibmFtZXMiOlsiQXV0aFByb3ZpZGVyIiwidXNlQXV0aCIsInVzZVJlcXVpcmVBdXRoIiwiaW5pdGlhbFN0YXRlIiwidXNlciIsImlzQXV0aGVudGljYXRlZCIsImlzTG9hZGluZyIsImlzSW5pdGlhbGl6ZWQiLCJpc0xvZ2dpbmdPdXQiLCJlcnJvciIsImF1dGhSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwicGF5bG9hZCIsIkF1dGhDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsImNoaWxkcmVuIiwiZGlzcGF0Y2giLCJ1c2VSZWR1Y2VyIiwicm91dGVyIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwiaW5pdGlhbGl6ZUF1dGgiLCJ0b2tlbiIsInRva2VuTWFuYWdlciIsImdldEFjY2Vzc1Rva2VuIiwic3RvcmVkVXNlciIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhcHBDb25maWciLCJzdG9yYWdlIiwiSlNPTiIsInBhcnNlIiwicGFyc2VFcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwicmVtb3ZlSXRlbSIsInJlc3BvbnNlIiwiYXBpIiwiZ2V0Q3VycmVudFVzZXIiLCJ1c2VyRGF0YSIsImRhdGEiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwicmVmcmVzaFRva2VuIiwiZ2V0UmVmcmVzaFRva2VuIiwicmVmcmVzaFRva2VuSW50ZXJuYWwiLCJyZWZyZXNoRXJyb3IiLCJsb2dvdXRJbnRlcm5hbCIsImNsZWFyVG9rZW5zIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsImtleSIsIkVycm9yIiwicmVmcmVzaEFjY2Vzc1Rva2VuIiwicmVmcmVzaF90b2tlbiIsImFjY2Vzc190b2tlbiIsIm5ld1JlZnJlc2hUb2tlbiIsInNldFRva2VucyIsImxvZ2luIiwiY3JlZGVudGlhbHMiLCJ0cmFja0V2ZW50IiwiaWRlbnRpZnlVc2VyIiwiaWQiLCJlbWFpbCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJzdWJzY3JpcHRpb25fdGllciIsIm1ldGhvZCIsInVzZXJfaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0cmFja2luZ0Vycm9yIiwidG9hc3QiLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImVycm9ycyIsInVua25vd24iLCJyZWdpc3RlciIsImNyZWF0ZWRfYXQiLCJtYXJrZXRpbmdfY29uc2VudCIsInNvdXJjZSIsImxvZ291dCIsImFuYWx5dGljcyIsInJlc2V0IiwibG9nIiwic2V0VGltZW91dCIsInJlcGxhY2UiLCJjbGVhckVycm9yIiwidXBkYXRlVXNlciIsInVwZGF0ZWRVc2VyIiwidmFsdWUiLCJQcm92aWRlciIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwicmVkaXJlY3RUbyIsImN1cnJlbnRQYXRoIiwiYXNQYXRoIiwicmVkaXJlY3RVcmwiLCJlbmNvZGVVUklDb21wb25lbnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkM7Ozs7Ozs7Ozs7O0lBc0xZQSxZQUFZO2VBQVpBOztJQThWYixPQUEyQjtlQUEzQjs7SUF4QmFDLE9BQU87ZUFBUEE7O0lBU0FDLGNBQWM7ZUFBZEE7Ozs7K0RBbmdCc0U7d0JBQ3pEO3FCQUNRO3dCQUNSO3NFQUVSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9EbEI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxlQUEwQjtJQUM5QkMsTUFBTTtJQUNOQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQyxjQUFjO0lBQ2RDLE9BQU87QUFDVDtBQUVBLGlGQUFpRjtBQUNqRixnQkFBZ0I7QUFDaEIsaUZBQWlGO0FBRWpGOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1DLGNBQWMsQ0FBQ0MsT0FBa0JDO0lBQ3JDLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBSztZQUNILE9BQU87Z0JBQUUsR0FBR0YsS0FBSztnQkFBRUwsV0FBV00sT0FBT0UsT0FBTztZQUFDO1FBRS9DLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdILEtBQUs7Z0JBQ1JQLE1BQU1RLE9BQU9FLE9BQU87Z0JBQ3BCVCxpQkFBaUIsQ0FBQyxDQUFDTyxPQUFPRSxPQUFPO2dCQUNqQ1IsV0FBVztnQkFDWEcsT0FBTztZQUNUO1FBRUYsS0FBSztZQUNILE9BQU87Z0JBQ0wsR0FBR0UsS0FBSztnQkFDUkYsT0FBT0csT0FBT0UsT0FBTztnQkFDckJSLFdBQVc7WUFDYjtRQUVGLEtBQUs7WUFDSCxPQUFPO2dCQUNMLEdBQUdLLEtBQUs7Z0JBQ1JKLGVBQWVLLE9BQU9FLE9BQU87Z0JBQzdCUixXQUFXLENBQUNNLE9BQU9FLE9BQU87WUFDNUI7UUFFRixLQUFLO1lBQ0gsT0FBTztnQkFD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